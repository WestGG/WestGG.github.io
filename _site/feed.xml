<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HELLO WORD</title>
    <description>Every failure is leading towards success.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 10 Aug 2018 00:00:07 +0800</pubDate>
    <lastBuildDate>Fri, 10 Aug 2018 00:00:07 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>理想监控系统</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文主要参考陈皓大哥的文章，在此基础之上结合自己的想法做了一个总结，还请多多指教。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;why-need-监控-&quot;&gt;Why need 监控 ??&lt;/h2&gt;

&lt;h4 id=&quot;监控系统起源与发展&quot;&gt;监控系统起源与发展&lt;/h4&gt;

&lt;h6 id=&quot;起源&quot;&gt;起源&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;分布式系统的出现是由于单机的性能瓶颈。&lt;/li&gt;
  &lt;li&gt;为了解决这个问题，必须将单体应用拆分到不同的机器上，不同的机器提供不同的服务来协同完成一件事。这就是分布式系统的演变过程。随着而来有很多问题，其中有个非常典型的问题即是。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;如果分布式系统一台机器出现问题，特别是支付行业，如何及时发现并挽救损失？？&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;答案就是&lt;strong&gt;监控&lt;/strong&gt;，这就是监控系统出现的最直接原因。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;发展&quot;&gt;发展&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;那么接下的问题就变成，如何打造一个符合要求的监控系统。为此，我们需要做到的目标为：&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;全栈监控&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cf/66/cf6fe8ee30a3ac3b693d1188b46e4e66.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;全链路监控&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;&lt;em&gt;Google Dapper -&amp;gt; 对应的开源实现Zipkin&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;国内：美团的 CAT，淘宝 eagle eye，微博的 Watchman，还有听云 Server 等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是好的监控系统&quot;&gt;什么是好的监控系统&lt;/h2&gt;

&lt;h4 id=&quot;特征&quot;&gt;特征&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;关注于整体应用的 SLA（service-level agreement)
    &lt;ul&gt;
      &lt;li&gt;即为对外提供的服务质量，关系到服务的可用性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;关联指标聚合
    &lt;ul&gt;
      &lt;li&gt;服务的具体实例和主机关联在一起,比如服务有可能运行在JVM OR Tomcat..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;快速故障定位
    &lt;ul&gt;
      &lt;li&gt;关键在于对一个请求的 trace 监控&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;监控什么&quot;&gt;监控什么&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;监控对象(全栈监控)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cf/66/cf6fe8ee30a3ac3b693d1188b46e4e66.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;请求链路(全链路监控)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/ab/81/ab79054e0a3cf2d8f1d696e3c367ab81.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;能力&quot;&gt;能力&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;体检能力
    &lt;ul&gt;
      &lt;li&gt;性能管理
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;通过系统大盘，找到系统瓶颈，并有针对性地优化系统和相应代码&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;容量管理
        &lt;ul&gt;
          &lt;li&gt;提供一个全局的系统运行时数据的展示，为&lt;strong&gt;扩容OR服务降级&lt;/strong&gt;提供决策依据&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;急诊能力
    &lt;ul&gt;
      &lt;li&gt;定位问题
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;以快速地暴露并找到问题的发生点，帮助技术人员诊断问题&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;性能分析
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;非预期的性能问题出现时，可以快速地找到系统的瓶颈，并可以帮助开发人员深入代码。&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;当我们做好以上要求的一些细节之后，当问题出现时，能达到的效果&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;了解故障的影响面&lt;/strong&gt;：
      &lt;ul&gt;
        &lt;li&gt;当一台机器挂掉是因为 CPU 或 I/O ， SQL 操作过慢 过高的时候，马上可以知道其会影响到哪些对外服务的 API&lt;/li&gt;
        &lt;li&gt;当一个服务响应过慢的时候，我们马上能关联出来是否在做 Java GC，或是其所在的计算结点上是否有资源不足的情况，或是依赖的服务是否出现了问题&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;可以做出调度&lt;/strong&gt;：
      &lt;ul&gt;
        &lt;li&gt;现某个服务过慢是因为 CPU 使用过多，就可以做弹性伸缩&lt;/li&gt;
        &lt;li&gt;发现某个服务过慢是因为 MySQL 出现了一个慢查询，就无法在应用层上做弹性伸缩，只能做流量限制，或是降级操作了&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;最终目的 -&amp;gt; 自动化运维&lt;/strong&gt;：
      &lt;ul&gt;
        &lt;li&gt;自动化扩容 OR 服务降级&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/6b/33/6b17dd779cfecd62e02924dc8618e833.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 09 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/09/monitorSystem/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/09/monitorSystem/</guid>
        
        <category>监控系统</category>
        
        
      </item>
    
      <item>
        <title>Java 字节码</title>
        <description>&lt;h4 id=&quot;简单的例子&quot;&gt;简单的例子&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 一段简单的代码
println(3+4);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 词法分析
3 4 + println
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3       // push 3 on the stack
4       // push 4 on the stack
+       // consume 3 and 4 and push the result on the stack
println // consume the result and print it
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题:如何将上面这段代码转化成为字节码？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h5 id=&quot;相关基础知识&quot;&gt;相关基础知识&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;JVM栈模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://java8.in/wp-content/uploads/2014/07/JVM_Structure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Object Model&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                                        
 *                                   Hotspot java object model(normal)
 *                                   /
 *            +--------------------+
 *            |      markWord      | 
 *            +--------------------+  
 *            |      metaData      | \
 *            +--------------------+  \
 *            |       field 0      |   Point to the Runtime  Class Object
 *            +--------------------+
 *            |       ....         |
 *            +--------------------+
 *            |       field N      |
 *            +--------------------+ 
 *            |       padding      |
 *            +--------------------+
 
//  markWord bits layout :
//  32 bits:
//  --------
//             hash:25 ------------&amp;gt;| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;bytecode简介&quot;&gt;ByteCode简介&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;字节码设计理念：&lt;strong&gt;&lt;em&gt;小而紧凑,面向对象&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;字节码格式&quot;&gt;字节码格式&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;index&amp;gt; &amp;lt;opcode&amp;gt; [ &amp;lt;operand1&amp;gt; [ &amp;lt;operand2&amp;gt;... ]] [&amp;lt;comment&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;opcode 的大小只有 1 byte(目前字节码总数 xx)；&lt;/li&gt;
  &lt;li&gt;针对一些字节码操作做出优化,使得字节码更短;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;字节码类型&quot;&gt;字节码类型&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;分类型：数值类型，引用类型 =&amp;gt; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html&quot;&gt;字节码助记符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结： &lt;strong&gt;针对不同的的运行时数据结构，VM 定义了相关的字节码，比如局部变量表的load+store两种字节码，再结合相关的类型，就是完整的局部变量表字节码集合&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;所以，经过上面的分析，printf(3+4) 转化为字节码是不是很简单了呢？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;大概的字节码如下(伪码)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 假设 3 和 4 为 int 类型: 

iconst_3       // push 3 on the stack
iconst_4       // push 4 on the stack
iadd           // consume 3 and 4 and push the result on the stack
invokestatic  println // consume the result and print it
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;复杂代码&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ## ConcurrentLinkedQueen.offer(E e)

 public boolean offer(E e) {
    checkNotNull(e);
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

    for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
        Node&amp;lt;E&amp;gt; q = p.next;
        if (q == null) {
          if (p.casNext(null, newNode)) {
             if (p != t)                   
                 casTail(t, newNode);
                 return true;
             }
        } else if (p == q)
            p = (t != (t = tail)) ? t : head;          // 这行代码有点复杂，对应的字节码如下
        else
           p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
    }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean offer(E);
    Code:
      ...

      58: aload         4                  // localvarTable[4] = p;
      60: aload         5                  // localvarTable[5] = q;
      62: if_acmpne     88                 // if (q==p) 
      65: aload_3                          // load t
      66: aload_0                          // load this
      67: getfield      #4                 // Field tail:Ljava/util/concurrent/ConcurrentLinkedQueue$Node;
      70: dup                              // operadStack :... t(old value),tail,tail
      71: astore_3                         // operadStack :... t(old value), tail   =&amp;gt; update t
      72: if_acmpeq     79                 // if( t(old value )== tail)

      ....

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NoSuchMethodError导致生产环境Cat OOM&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;由于Java8 编译，Java7 环境运行，导致NoSuchMethodError：&lt;/li&gt;
    &lt;li&gt;下图是cat server 消费消息的流程：
      &lt;ul&gt;
        &lt;li&gt;NosuchMehodError 最终导致DumpAnalyzer 挂掉，消息无法及时刷回磁盘，最终导致OOM。&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;得出的教训：
      &lt;ul&gt;
        &lt;li&gt;各个环境的JDK运行环境要一致；&lt;/li&gt;
        &lt;li&gt;有时环境问题并不能选择，那么面向接口编程是最好的选择；&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;graph LR
Receiver--&amp;gt; realComsumer
realComsumer--&amp;gt; PeriodTask
PeriodTask--&amp;gt; Analyzer
Analyzer--&amp;gt;makeReport
Analyzer--&amp;gt;dumpFile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;罪魁祸首&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 原先的代码
    ConcurrentHashMap&amp;lt;String, String&amp;gt; map = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    map.keySet();
        
        //修改后的代码
    ConcurrentMap&amp;lt;String, String&amp;gt; map1 = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    map1.keySet();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Code:
       0: new           #2                  // class java/util/concurrent/ConcurrentHashMap
       3: dup
       4: invokespecial #3                  // Method java/util/concurrent/ConcurrentHashMap.&quot;&amp;lt;init&amp;gt;&quot;:()V
       7: astore_1
       8: aload_1
       9: invokevirtual #4                  // Method java/util/concurrent/ConcurrentHashMap.keySet:()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;
      12: pop
      13: new           #2                  // class java/util/concurrent/ConcurrentHashMap
      16: dup
      17: invokespecial #3                  // Method java/util/concurrent/ConcurrentHashMap.&quot;&amp;lt;init&amp;gt;&quot;:()V
      20: astore_2
      21: aload_2
      22: invokeinterface #5,  1            // InterfaceMethod java/util/concurrent/ConcurrentMap.keySet:()Ljava/util/Set;
      27: pop
      28: return

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;finally&quot;&gt;Finally&lt;/h4&gt;

&lt;p&gt;献上 &lt;a href=&quot;https://slides.com/heizhan/deck#/&quot;&gt;slidesPPT之Java字节码从入门到放弃&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; _____________ 
&amp;lt; ThankYou ~  &amp;gt;
 ------------- 
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot;&gt;The Java® Virtual Machine Specification Java SE 8 Edition&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_virtual_machine&quot;&gt;wiki-Java virtual machine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp&quot;&gt;markOop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/08/javaBytecode/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/08/javaBytecode/</guid>
        
        <category>bytecode</category>
        
        
      </item>
    
      <item>
        <title>Hello Word</title>
        <description>&lt;h2 id=&quot;文章分类&quot;&gt;文章分类&lt;/h2&gt;

&lt;h3 id=&quot;jvm&quot;&gt;JVM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;为何JVM&lt;/li&gt;
  &lt;li&gt;从JVM 谈Java
    &lt;ul&gt;
      &lt;li&gt;Java字节码&lt;/li&gt;
      &lt;li&gt;从JVM谈Java面向对象的实现机制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JVM相关技术
    &lt;ul&gt;
      &lt;li&gt;内存管理&lt;/li&gt;
      &lt;li&gt;即时编译器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;相关资源
    &lt;ul&gt;
      &lt;li&gt;todo&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;h4 id=&quot;监控系统cat实现剖析&quot;&gt;监控系统Cat实现剖析&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为何需要监控系统&lt;/li&gt;
  &lt;li&gt;高性能Cat的实现,从客户端到服务端&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;linux-常用命令集合&quot;&gt;Linux 常用命令集合&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Linux 常用命令集合&lt;/li&gt;
  &lt;li&gt;Linux 调优命令集合&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;读书笔记&quot;&gt;读书笔记&lt;/h4&gt;

</description>
        <pubDate>Sat, 08 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/08/helloWorld/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/08/helloWorld/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
