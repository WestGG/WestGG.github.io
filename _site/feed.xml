<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HELLO WORD</title>
    <description>Every failure is leading towards success.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 18 Aug 2018 10:10:16 +0800</pubDate>
    <lastBuildDate>Sat, 18 Aug 2018 10:10:16 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Java Object model</title>
        <description>&lt;h2 id=&quot;q如何计算对象的大小&quot;&gt;Q:如何计算对象的大小&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object object = new Object();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;预备知识&quot;&gt;预备知识&lt;/h2&gt;

&lt;h4 id=&quot;对象组成&quot;&gt;对象组成&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Object model = header + body&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; *  普通对象
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       ....         |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
 
 *  数组对象
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | 
 *  |      metaData      |  | header
 *  +--------------------+  |
 *  |      length        | /
 *  +--------------------+ 
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       ....         |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
 
//  markWord bits layout :
//  32 bits:
//  --------
//             hash:25 ------------&amp;gt;| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
// meteData is a pointer pointing to class .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;字段&quot;&gt;字段&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;字段继承&lt;/li&gt;
  &lt;li&gt;字段排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;预备知识-1&quot;&gt;预备知识&lt;/h4&gt;

&lt;h5 id=&quot;字段继承与排序&quot;&gt;字段继承与排序&lt;/h5&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h6 id=&quot;字段继承&quot;&gt;字段继承&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;在面向对象的设计中，子类会继承父类的字段，虚方法等。Java作为面向对象实现最彻底的语言亦遵守这个规定&lt;/li&gt;
  &lt;li&gt;在Hotspot的实现中，子类的object model 将继承得来的字段直接存储在对象中&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;字段排序&quot;&gt;字段排序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;为了更好地利用内存，会在对象内对字段进行排序，顺序为：8bytes,4bytes,2bytes,1bytes，指针类型最后&lt;/li&gt;
  &lt;li&gt;在字段排序的同时会进行内存对齐，但这会带来一定的内存浪费&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;对齐原则&quot;&gt;对齐原则&lt;/h6&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;对齐主要有对象之间对齐，字段之间对齐&lt;/li&gt;
    &lt;li&gt;下图 : N 表示倍数关系，C代表基本类型的长度(比如long:8bytes,int:4bytes),同时压缩代表有无开启压缩指针&lt;/li&gt;
    &lt;li&gt;Note : 子类字段与父类之间的对齐按照对象对齐原则来&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;64位CPU，压缩&lt;/th&gt;
      &lt;th&gt;对象&lt;/th&gt;
      &lt;th&gt;字段&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;对象&lt;/td&gt;
      &lt;td&gt;4N&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字段&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;CN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;64位CPU，无压缩&lt;/th&gt;
      &lt;th&gt;对象&lt;/th&gt;
      &lt;th&gt;字段&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;对象&lt;/td&gt;
      &lt;td&gt;8N&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字段&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;CN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;gap-与-padding&quot;&gt;gap 与 padding&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;gap技术可用于填充对象和字段对齐带来的内存浪费空间。例如，对象对齐时出现5bytes 空间浪费，优先对齐基本类型4bytes,其他基本类型的优先级按照长度来排。
    &lt;ul&gt;
      &lt;li&gt;不同的虚拟机在实现时稍微有点差别 ：在hotspot中，对象对齐的内存空间并无使用gap,据说为历史遗留原因；而JikesVRVM则在很好地利用了对象对齐锁带来的内存空间浪费。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;padding技术之为了解决对象层面的内存对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; *  可能存在的对象内存布局长相 :  
 * 
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       gap          |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;new Object( )&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; *  new Object( )
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 
 Q : 下图的对象大小为多少 ？

 A.8 bytes      B.16bytes    C.12bytes   D. 都不对

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;答案为-d-考虑的方向&quot;&gt;答案为 D ,考虑的方向！&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 位数&lt;/li&gt;
  &lt;li&gt;JVM的指针压缩技术,具体参数为-XX:+UseCompressedOops,默认开启&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;解析如下：&lt;/li&gt;
    &lt;li&gt;当环境为64位CPU且开启压缩指针(默认开启，当内存超过2^35=32G时，会关闭压缩指针) ： 假设起始位置为0,对应的大小如下 ： 选C&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; *  new Object( )
 *  0                   64     
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+
    65                   96
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;对于A， 环境为32位CPU 即可；&lt;/li&gt;
    &lt;li&gt;对于B， 环境我64位CPU且无开启压缩指针即可；&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;new B( )&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A {
    int i;
    long l;
}

Class B extend A {
    String b;
    
    private void test() {
        B b = new B();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// new B( ) 内存布局:

//hotspot 64 位CPU，指针压缩,按照对齐原则 :
    0                    8
 *  +--------------------+ 
 *  |      markWord      |   \
 *  +--------------------+ 12 |header
 *  |      metaData      |   /
 *  +--------------------+ 16 --&amp;gt; 首字段对齐,gap填充int i
 *  |       int i        | 
 *  +--------------------+ 24 --&amp;gt; 刚好整除4,不用对齐(对象对齐) 
 *  |       long l       |  
 *  +--------------------+ 28 --&amp;gt; 刚好整除4，不用padding(对象对齐)
 *  |       String b     |  
 *  +--------------------+  


// hotspot 64 位CPU，无指针压缩,按照对齐原则 : 
    0                    8
 *  +--------------------+ 
 *  |      markWord      |   \
 *  +--------------------+16 |header --&amp;gt; 首字段不用对齐
 *  |      metaData      |   /
 *  +--------------------+24 --&amp;gt;  刚好整除8，不用对齐(字段对齐)
 *  |       long l       | 
 *  +--------------------+28 --&amp;gt;  不能整除8,对齐到32(对象对齐) 
 *  |       int i        |  
 *  +--------------------+32 
 *  |       gap          |  
 *  +--------------------+40 --&amp;gt; 刚好整除8，不同padding(对象对齐)
 *  |       string b     |  
 *  +--------------------+  


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 17 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/17/javaObjectMode/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/17/javaObjectMode/</guid>
        
        <category>objectmodel</category>
        
        
      </item>
    
      <item>
        <title>理想监控系统</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文主要参考陈皓大哥的文章，在此基础之上结合自己的想法做了一个总结，还请多多指教。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;why-need-监控-&quot;&gt;Why need 监控 ??&lt;/h2&gt;

&lt;h4 id=&quot;监控系统起源与发展&quot;&gt;监控系统起源与发展&lt;/h4&gt;

&lt;h6 id=&quot;起源&quot;&gt;起源&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;分布式系统的出现是由于单机的性能瓶颈。&lt;/li&gt;
  &lt;li&gt;为了解决这个问题，必须将单体应用拆分到不同的机器上，不同的机器提供不同的服务来协同完成一件事。这就是分布式系统的演变过程。随着而来有很多问题，其中有个非常典型的问题即是。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;如果分布式系统一台机器出现问题，特别是支付行业，如何及时发现并挽救损失？？&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;答案就是&lt;strong&gt;监控&lt;/strong&gt;，这就是监控系统出现的最直接原因。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;发展&quot;&gt;发展&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;那么接下的问题就变成，如何打造一个符合要求的监控系统。为此，我们需要做到的目标为：&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;全栈监控&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cf/66/cf6fe8ee30a3ac3b693d1188b46e4e66.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;全链路监控&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;&lt;em&gt;Google Dapper -&amp;gt; 对应的开源实现Zipkin&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;国内：美团的 CAT，淘宝 eagle eye，微博的 Watchman，还有听云 Server 等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是好的监控系统&quot;&gt;什么是好的监控系统&lt;/h2&gt;

&lt;h4 id=&quot;特征&quot;&gt;特征&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;关注于整体应用的 SLA（service-level agreement)
    &lt;ul&gt;
      &lt;li&gt;即为对外提供的服务质量，关系到服务的可用性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;关联指标聚合
    &lt;ul&gt;
      &lt;li&gt;服务的具体实例和主机关联在一起,比如服务有可能运行在JVM OR Tomcat..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;快速故障定位
    &lt;ul&gt;
      &lt;li&gt;关键在于对一个请求的 trace 监控&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;监控什么&quot;&gt;监控什么&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;监控对象(全栈监控)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cf/66/cf6fe8ee30a3ac3b693d1188b46e4e66.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;请求链路(全链路监控)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/ab/81/ab79054e0a3cf2d8f1d696e3c367ab81.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;能力&quot;&gt;能力&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;体检能力
    &lt;ul&gt;
      &lt;li&gt;性能管理
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;通过系统大盘，找到系统瓶颈，并有针对性地优化系统和相应代码&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;容量管理
        &lt;ul&gt;
          &lt;li&gt;提供一个全局的系统运行时数据的展示，为&lt;strong&gt;扩容OR服务降级&lt;/strong&gt;提供决策依据&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;急诊能力
    &lt;ul&gt;
      &lt;li&gt;定位问题
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;以快速地暴露并找到问题的发生点，帮助技术人员诊断问题&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;性能分析
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;非预期的性能问题出现时，可以快速地找到系统的瓶颈，并可以帮助开发人员深入代码。&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;当我们做好以上要求的一些细节之后，当问题出现时，能达到的效果&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;了解故障的影响面&lt;/strong&gt;：
      &lt;ul&gt;
        &lt;li&gt;当一台机器挂掉是因为 CPU 或 I/O ， SQL 操作过慢 过高的时候，马上可以知道其会影响到哪些对外服务的 API&lt;/li&gt;
        &lt;li&gt;当一个服务响应过慢的时候，我们马上能关联出来是否在做 Java GC，或是其所在的计算结点上是否有资源不足的情况，或是依赖的服务是否出现了问题&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;可以做出调度&lt;/strong&gt;：
      &lt;ul&gt;
        &lt;li&gt;现某个服务过慢是因为 CPU 使用过多，就可以做弹性伸缩&lt;/li&gt;
        &lt;li&gt;发现某个服务过慢是因为 MySQL 出现了一个慢查询，就无法在应用层上做弹性伸缩，只能做流量限制，或是降级操作了&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;最终目的 -&amp;gt; 自动化运维&lt;/strong&gt;：
      &lt;ul&gt;
        &lt;li&gt;自动化扩容 OR 服务降级&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/6b/33/6b17dd779cfecd62e02924dc8618e833.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 09 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/09/monitorSystem/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/09/monitorSystem/</guid>
        
        <category>监控系统</category>
        
        
      </item>
    
      <item>
        <title>Java 字节码</title>
        <description>&lt;h4 id=&quot;简单的例子&quot;&gt;简单的例子&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 一段简单的代码
println(3+4);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 词法分析
3 4 + println
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3       // push 3 on the stack
4       // push 4 on the stack
+       // consume 3 and 4 and push the result on the stack
println // consume the result and print it
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题:如何将上面这段代码转化成为字节码？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h5 id=&quot;相关基础知识&quot;&gt;相关基础知识&lt;/h5&gt;

&lt;h6 id=&quot;jvm栈模型&quot;&gt;JVM栈模型&lt;/h6&gt;

&lt;p&gt;如何将JVM的栈模型与我们已有的认知映射起来呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法对应着栈帧&lt;/li&gt;
  &lt;li&gt;方法的参数和局部变量对应着局部变量表&lt;/li&gt;
  &lt;li&gt;CPU的寄存器对应着操作数栈(operandStack)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;此刻，学习的重心应该围绕着OperandStack，因为字节码的设计都是围绕着OperandStack。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局部变量表的load,store系列指令对应数据(可以是数值类型，也可以是引用类型)与OperandStack的交互：push,pop；&lt;/li&gt;
  &lt;li&gt;常量池的const，ldc系列指令对应数据与OperandStack的交互：push;&lt;/li&gt;
  &lt;li&gt;另外，方法之间的相互调用则是invoke系统指令,这是个打的话题，后面话有个专门的文章来讲；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://java8.in/wp-content/uploads/2014/07/JVM_Structure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;object-model&quot;&gt;Object Model&lt;/h6&gt;

&lt;blockquote&gt;
  &lt;p&gt;Object Model代表着一个对象在内存中的布局，虚拟机规范针对此设计系列的指令,来访问和赋值实例变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;主要指令有：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getfield -&amp;gt; 访问实例变量；&lt;/li&gt;
  &lt;li&gt;putfield -&amp;gt; 给实例变量赋值;&lt;/li&gt;
  &lt;li&gt;对于类变量的访问和赋值则有: getstatic,putstatic系列指令；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;下图为普通对象在内存中的布局，对于数组：其头部多加了一length表示数组长度，对应着arraylength指令&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                                        
 *                                   Hotspot java object model(normal)
 *                                   /
 *            +--------------------+
 *            |      markWord      | 
 *            +--------------------+  
 *            |      metaData      | \
 *            +--------------------+  \
 *            |       field 0      |   Point to the Runtime  Class Object
 *            +--------------------+
 *            |       ....         |
 *            +--------------------+
 *            |       field N      |
 *            +--------------------+ 
 *            |       padding      |
 *            +--------------------+
 
//  markWord bits layout :
//  32 bits:
//  --------
//             hash:25 ------------&amp;gt;| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;bytecode简介&quot;&gt;ByteCode简介&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;字节码设计理念：&lt;strong&gt;小而紧凑,面向类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;字节码格式&quot;&gt;字节码格式&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;index&amp;gt; &amp;lt;opcode&amp;gt; [ &amp;lt;operand1&amp;gt; [ &amp;lt;operand2&amp;gt;... ]] [&amp;lt;comment&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;opcode 的大小只有 1 byte(理论字节码总数为2^8 个)；&lt;/li&gt;
  &lt;li&gt;针对一些字节码操作做出优化,使得字节码更短;
    &lt;ul&gt;
      &lt;li&gt;比如const系列指令；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;字节码类型&quot;&gt;字节码类型&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;分类型：数值类型，引用类型 =&amp;gt; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html&quot;&gt;字节码助记符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结： &lt;strong&gt;针对不同的的运行时数据结构，VM 定义了相关的字节码，比如局部变量表的load+store两种字节码，再结合相关的类型，就是完整的局部变量表字节码集合&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;所以，经过上面的分析，printf(3+4) 转化为字节码是不是很简单了呢？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;大概的字节码如下(伪码)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 假设 3 和 4 为 int 类型: 

iconst_3       // push 3 on the stack
iconst_4       // push 4 on the stack
iadd           // consume 3 and 4 and push the result on the stack
invokestatic  println // consume the result and print it
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;examples&quot;&gt;Examples&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;复杂代码&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ## ConcurrentLinkedQueen.offer(E e)

 public boolean offer(E e) {
    checkNotNull(e);
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

    for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
        Node&amp;lt;E&amp;gt; q = p.next;
        if (q == null) {
          if (p.casNext(null, newNode)) {
             if (p != t)                   
                 casTail(t, newNode);
                 return true;
             }
        } else if (p == q)
            p = (t != (t = tail)) ? t : head;          // 这行代码有点复杂，对应的字节码如下
        else
           p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
    }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean offer(E);
    Code:
      ...

      58: aload         4                  // localvarTable[4] = p;
      60: aload         5                  // localvarTable[5] = q;
      62: if_acmpne     88                 // if (q==p) 
      65: aload_3                          // load t
      66: aload_0                          // load this
      67: getfield      #4                 // Field tail:Ljava/util/concurrent/ConcurrentLinkedQueue$Node;
      70: dup                              // operadStack :... t(old value),tail,tail
      71: astore_3                         // operadStack :... t(old value), tail   =&amp;gt; update t
      72: if_acmpeq     79                 // if( t(old value )== tail)

      ....

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NoSuchMethodError导致生产环境Cat OOM&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;由于Java8 编译，Java7 环境运行，导致NoSuchMethodError：&lt;/li&gt;
    &lt;li&gt;下图是cat server 消费消息的流程：
      &lt;ul&gt;
        &lt;li&gt;NosuchMehodError 最终导致DumpAnalyzer 挂掉，消息无法及时刷回磁盘，最终导致OOM。&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;得出的教训：
      &lt;ul&gt;
        &lt;li&gt;各个环境的JDK运行环境要一致；&lt;/li&gt;
        &lt;li&gt;有时环境问题并不能选择，那么面向接口编程是最好的选择；&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;graph LR
Receiver--&amp;gt; realComsumer
realComsumer--&amp;gt; PeriodTask
PeriodTask--&amp;gt; Analyzer
Analyzer--&amp;gt;makeReport
Analyzer--&amp;gt;dumpFile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;罪魁祸首&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 原先的代码
    ConcurrentHashMap&amp;lt;String, String&amp;gt; map = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    map.keySet();
        
        //修改后的代码
    ConcurrentMap&amp;lt;String, String&amp;gt; map1 = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    map1.keySet();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Code:
       0: new           #2                  // class java/util/concurrent/ConcurrentHashMap
       3: dup
       4: invokespecial #3                  // Method java/util/concurrent/ConcurrentHashMap.&quot;&amp;lt;init&amp;gt;&quot;:()V
       7: astore_1
       8: aload_1
       9: invokevirtual #4                  // Method java/util/concurrent/ConcurrentHashMap.keySet:()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;
      12: pop
      13: new           #2                  // class java/util/concurrent/ConcurrentHashMap
      16: dup
      17: invokespecial #3                  // Method java/util/concurrent/ConcurrentHashMap.&quot;&amp;lt;init&amp;gt;&quot;:()V
      20: astore_2
      21: aload_2
      22: invokeinterface #5,  1            // InterfaceMethod java/util/concurrent/ConcurrentMap.keySet:()Ljava/util/Set;
      27: pop
      28: return

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;finally&quot;&gt;Finally&lt;/h4&gt;

&lt;p&gt;献上 &lt;a href=&quot;https://slides.com/heizhan/deck#/&quot;&gt;slidesPPT之Java字节码从入门到放弃&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; _____________ 
&amp;lt; ThankYou ~  &amp;gt;
 ------------- 
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot;&gt;The Java® Virtual Machine Specification Java SE 8 Edition&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_virtual_machine&quot;&gt;wiki-Java virtual machine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp&quot;&gt;markOop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/08/javaBytecode/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/08/javaBytecode/</guid>
        
        <category>bytecode</category>
        
        
      </item>
    
      <item>
        <title>Hello Word</title>
        <description>&lt;h2 id=&quot;文章分类&quot;&gt;文章分类&lt;/h2&gt;

&lt;h3 id=&quot;jvm&quot;&gt;JVM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;从JVM 谈Java
    &lt;ul&gt;
      &lt;li&gt;Java字节码&lt;/li&gt;
      &lt;li&gt;从JVM谈Java面向对象的实现机制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JVM相关技术
    &lt;ul&gt;
      &lt;li&gt;内存管理&lt;/li&gt;
      &lt;li&gt;即时编译器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;相关资源
    &lt;ul&gt;
      &lt;li&gt;todo&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;h4 id=&quot;监控系统cat实现剖析&quot;&gt;监控系统Cat实现剖析&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为何需要监控系统&lt;/li&gt;
  &lt;li&gt;高性能Cat的实现,从客户端到服务端&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;linux-常用命令集合&quot;&gt;Linux 常用命令集合&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Linux 常用命令集合&lt;/li&gt;
  &lt;li&gt;Linux 调优命令集合&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;读书笔记&quot;&gt;读书笔记&lt;/h4&gt;

</description>
        <pubDate>Sun, 08 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/08/helloWorld/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/08/helloWorld/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
