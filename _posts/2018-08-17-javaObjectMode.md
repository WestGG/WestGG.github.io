---
layout:     post                    # 使用的布局（不需要改）
title:      Java Object model       # 标题 
subtitle:   对象大小计算            #副标题
date:       2018-08-17              # 时间
author:     west                    # 作者
header-img: img/post_green.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - objectmodel
---
## Q:如何计算对象的大小


```
Object object = new Object();
```

## 预备知识

#### 对象组成

> Object model = header + body

```
 *  普通对象
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       ....         |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
 
 *  数组对象
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | 
 *  |      metaData      |  | header
 *  +--------------------+  |
 *  |      length        | /
 *  +--------------------+ 
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       ....         |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
 
//  markWord bits layout :
//  32 bits:
//  --------
//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
// meteData is a pointer pointing to class .
```

##### 字段

- 字段继承
- 字段排序

##### 字段继承与排序

###### 字段继承
- 在面向对象的设计中，子类会继承父类的字段，虚方法等。Java作为面向对象实现最彻底的语言亦遵守这个规定
- 在Hotspot的实现中，子类的object model 将继承得来的字段直接存储在对象中

###### 字段排序
- 为了更好地利用内存，会在对象内对字段进行排序，顺序为：8bytes,4bytes,2bytes,1bytes，指针类型最后
- 在字段排序的同时会进行内存对齐，但这会带来一定的内存浪费

###### 对齐原则

> - 对齐主要有对象之间对齐，字段之间对齐
> - 下图 : N 表示倍数关系，C代表基本类型的长度(比如long:8bytes,int:4bytes),同时压缩代表有无开启压缩指针
> - Note : 子类字段与父类之间的对齐按照对象对齐原则来
 
64位CPU，压缩| 对象 | 字段
---|---|---
 对象 | 4N |
 字段 |    | CN

64位CPU，无压缩| 对象 | 字段west

---|---|---
 对象 | 8N |
 字段 |    | CN

##### gap 与 padding

- gap技术可用于填充对象和字段对齐带来的内存浪费空间。例如，对象对齐时出现5bytes 空间浪费，优先对齐基本类型4bytes,其他基本类型的优先级按照长度来排。
  - 不同的虚拟机在实现时稍微有点差别 ：在hotspot中，对象对齐的内存空间并无使用gap,据说为历史遗留原因；而JikesVRVM则在很好地利用了对象对齐锁带来的内存空间浪费。
- padding技术之为了解决对象层面的内存对齐。


```
 *  可能存在的对象内存布局长相 :  
 * 
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       gap          |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
```


## Example

####  new Object( )

```
 *  new Object( )
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 
 Q : 下图的对象大小为多少 ？

 A.8 bytes      B.16bytes    C.12bytes   D. 都不对

```

##### 答案为 D ,考虑的方向！

- CPU 位数
- JVM的指针压缩技术,具体参数为-XX:+UseCompressedOops,默认开启

> - 解析如下：
> - 当环境为64位CPU且开启压缩指针(默认开启，当内存超过2^35=32G时，会关闭压缩指针) ： 假设起始位置为0,对应的大小如下 ： 选C


```
 *  new Object( )
 *  0                   64     
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+
    65                   96
```
> - 对于A， 环境为32位CPU 即可；
> - 对于B， 环境我64位CPU且无开启压缩指针即可；

---

#### new B( )

```
Class A {
    int i;
    long l;
}

Class B extend A {
    String b;
    
    private void test() {
        B b = new B();
    }
}
```


```
// new B( ) 内存布局:

//hotspot 64 位CPU，指针压缩,按照对齐原则 :
    0                    8
 *  +--------------------+ 
 *  |      markWord      |   \
 *  +--------------------+ 12 |header
 *  |      metaData      |   /
 *  +--------------------+ 16 --> 首字段对齐,gap填充int i
 *  |       int i        | 
 *  +--------------------+ 24 --> 刚好整除4,不用对齐(对象对齐) 
 *  |       long l       |  
 *  +--------------------+ 28 --> 刚好整除4，不用padding(对象对齐)
 *  |       String b     |  
 *  +--------------------+  


// hotspot 64 位CPU，无指针压缩,按照对齐原则 : 
    0                    8
 *  +--------------------+ 
 *  |      markWord      |   \
 *  +--------------------+16 |header --> 首字段不用对齐
 *  |      metaData      |   /
 *  +--------------------+24 -->  刚好整除8，不用对齐(字段对齐)
 *  |       long l       | 
 *  +--------------------+28 -->  不能整除8,对齐到32(对象对齐) 
 *  |       int i        |  
 *  +--------------------+32 
 *  |       gap          |  
 *  +--------------------+40 --> 刚好整除8，不同padding(对象对齐)
 *  |       string b     |  
 *  +--------------------+  


```


