---
layout:     post                    # 使用的布局（不需要改）
title:      Java Object Model       # 标题 
subtitle:   对象大小计算            #副标题
date:       2018-08-17              # 时间
author:     west                    # 作者
header-img: img/post_green.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - objectmodel
---
## Q:如何计算hotspot虚拟机中对象的大小

```
// 求object对象的大小
Object object = new Object();
```


## 预备知识

#### 对象组成

> - Object model = header + body.
> - 在hotspot的的对象模型中，对象由header以及body两部分组成。其中body存储对象的实例变量字段，而header则包含markword+metadata.

```
 *  普通对象
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       ....         |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
 
 *  数组对象
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | 
 *  |      metaData      |  | header
 *  +--------------------+  |
 *  |      length        | /
 *  +--------------------+ 
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       ....         |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
 
//  markWord bits layout :
//  32 bits:
//  --------
//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
// meteData is a pointer pointing to class .
```

##### 字段

> 知道了对象的内存布局之后，是可以计算出当前类的实例变量字段大小，但Java作为一门面向对象语言，子类会继承父类的实例变量字段，因此在计算对象的大小时，需要考虑字段继承问题.

- 字段继承
- 字段排序

##### 字段继承与排序

###### 字段继承
- 在面向对象的设计中，子类会继承父类的字段，虚方法等。Java作为面向对象实现最彻底的语言亦遵守这个规定
 在Hotspot的实现中，子类的object model 将继承得来的字段直接存储在对象中

###### 字段排序
- 为了更好地利用内存，会在对象内对字段进行排序，顺序为：8bytes,4bytes,2bytes,1bytes，指针类型最后
- 在字段排序的同时会进行内存对齐，但这会带来一定的内存浪费

###### 对齐原则

> - 对齐主要有对象之间对齐，字段之间对齐
> - 下图 : N 表示倍数关系，C代表基本类型的长度(比如long:8bytes,int:4bytes),同时压缩代表有无开启压缩指针
> - Note : 子类字段与父类之间的对齐按照对象对齐原则来
 
64位CPU，压缩| 对象 | 字段
---|---|---
 对象 | 4N |
 字段 |    | CN

64位CPU，无压缩| 对象 | 字段west

---|---|---
 对象 | 8N |
 字段 |    | CN

##### gap 与 padding

- gap技术可用于填充对象和字段对齐带来的内存浪费空间。例如，对象对齐时出现5bytes 空间浪费，优先对齐基本类型4bytes,其他基本类型的优先级按照长度来排。
  - 不同的虚拟机在实现时稍微有点差别 ：在hotspot中，对象对齐的内存空间并无使用gap,据说为历史遗留原因；而JikesVRVM则在很好地利用了对象对齐锁带来的内存空间浪费。
- padding技术之为了解决对象层面的内存对齐。


```
 *  可能存在的对象内存布局长相 :  
 * 
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 *  |       field 0      | \
 *  +--------------------+  |
 *  |       gap          |  | 
 *  +--------------------+  | body
 *  |       field N      |  |
 *  +--------------------+  |
 *  |       padding      | /
 *  +--------------------+
```


## Example

> 经过前面预备知识的铺垫，现在来尝试下计算对象的大小吧

####  new Object( )

```
 *  new Object( )
 *                          
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+  
 
 Q : 下图的对象大小为多少 ？

 A.8 bytes      B.16bytes    C.12bytes   D. 都不对

```

##### 答案为 D ,考虑的方向！

- CPU 位数
- JVM的指针压缩技术,具体参数为-XX:+UseCompressedOops,默认开启

> - 解析如下：
> - 当环境为64位CPU且开启压缩指针(默认开启，当内存超过2^35=32G时，会关闭压缩指针) ： 假设起始位置为0,对应的大小如下 ： 选C


```
 *  new Object( )
 *  0                   64     
 *  +--------------------+ 
 *  |      markWord      | \
 *  +--------------------+  | header
 *  |      metaData      | /
 *  +--------------------+
    65                   96
```
> - 对于A， 环境为32位CPU 即可；
> - 对于B， 环境我64位CPU且无开启压缩指针即可；

---

#### new B( )

```
Class A {
    int i;
    long l;
}

Class B extend A {
    String b;
    
    private void test() {
        B b = new B();
    }
}
```


```
// new B( ) 内存布局:

//hotspot 64 位CPU，指针压缩,按照对齐原则 :
    0                    8
 *  +--------------------+ 
 *  |      markWord      |   \
 *  +--------------------+ 12 |header
 *  |      metaData      |   /
 *  +--------------------+ 16 --> 首字段对齐,gap填充int i
 *  |       int i        | 
 *  +--------------------+ 24 --> 刚好整除4,不用对齐(对象对齐) 
 *  |       long l       |  
 *  +--------------------+ 28 --> 刚好整除4，不用padding(对象对齐)
 *  |       String b     |  
 *  +--------------------+  


// hotspot 64 位CPU，无指针压缩,按照对齐原则 : 
    0                    8
 *  +--------------------+ 
 *  |      markWord      |   \
 *  +--------------------+16 |header --> 首字段不用对齐
 *  |      metaData      |   /
 *  +--------------------+24 -->  刚好整除8，不用对齐(字段对齐)
 *  |       long l       | 
 *  +--------------------+28 -->  不能整除8,对齐到32(对象对齐) 
 *  |       int i        |  
 *  +--------------------+32 
 *  |       gap          |  
 *  +--------------------+40 --> 刚好整除8，不同padding(对象对齐)
 *  |       string b     |  
 *  +--------------------+  
```

---

## 总结

本文讲解了如何计算Java对象大小，具体的思路为：
- 对象的组成部分，在Java对象内存模型(即为Java Object Model)的实现中： 对象 = header+body,这是Java对象大小计算的基础
- 相关预备知识，比如内存对齐所带来的gap和padding。要理解gap和padding，其重点在于理解为什么需要对齐？还是因为**CPU的寻址机制**
- 最后，用两个小例子，讲解了如何在32位和64位CPU平台计算对象大小，需要注意的是64位CPU平台可以实现压缩指针 => [赠送slides-ppt](https://slides.com/heizhan/object-model#/)
