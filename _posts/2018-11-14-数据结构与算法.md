---
layout:     post                    # 使用的布局（不需要改）
title:      数据结构与算法            # 标题
subtitle:   温故而知新               #副标题
date:       2018-11-14              # 时间
author:     west                    # 作者
header-img: img/post_green.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 数据结构与算法
---

## TODO

```
  1.基本的数据结构:
  
 (数组) ---> (队列，栈) ---> (树，堆)
        /                       ==>  (图)
 (链表) / 
 
    
  
  2.基本的排序算法:
  
  O(n^2)=(插入，冒泡，选择)   ==> O(n*lgn)=(归并，快排) ==> O(n)=(桶，计数，基数)
  
  3.相关的思想
  
  递归 ==> 动规、 二分等
  
  4.相关演变出来的数据结构
 (数组) ---> (跳表，哈希表)
        /  
 (链表) / 
 
```


## 基本的数据结构

### 数组

```.java
/* note： 
    1.To understand meaning of the index , you hava to kown well about field size
    
    2.You must be careful with field numToMove,for moving the data to keep array memory in sequence!    
*/
package collection;

public class Array {
    public int[] data;
    public int capacity;
    public int size;

    public void insert(int index,int value) {
        if(index<0 || index>size)
            throw new IndexOutOfBoundsException();
        if(size>=capacity)
            throw new IllegalStateException("the array is full!");

        int numToMove = size-index;
        if(numToMove>0)
            for(int i=size; i>index; i--)
                data[i]=data[i-1];

        data[index] = value;

        size++;
    }

    public void delete(int index) {
        if(index<0 || index>=size)
            throw new IndexOutOfBoundsException();

        int numToMove = size-index-1;
        if(numToMove>0)
            for(int i=index; i<size; i++)
                data[i] = data[i+1];

        size--;
    }
}
```
<img src="https://docs.oracle.com/javase/tutorial/figures/java/objects-tenElementArray.gif" height="150" weight="200" border="5"/>

### 链表


```.java
package collection;

public class LinkedList {
    public Node head;
    public Node tail;
    public int length;

    public LinkedList() {}

    public void insert(int data) {
        Node tmp = tail;
        Node node = new Node(data);

        //check head
        if(head==null)
            head = node;

        if(tmp!=null)
            tmp.next=node;

        node.prev=tmp;

        tail=node;
        length++;
    }

    public int delete(int  data) {
        Node tmp = head;
        while(tmp!=null)  {
            if(tmp.item == data) {
                unlink(tmp);
                break;
            }
            else
                tmp = tmp.next;
        }

        if(tmp==null)
            throw new IllegalArgumentException("the data does not exit");

        length--;

        return tmp.item;
    }

    private void unlink(Node tmp) {
        Node prev = tmp.prev;
        Node next = tmp.next;

        if(prev==null)
            head = next;
        else {
            prev.next = next;
            tmp.prev  = null;      //take care!!
        }

        if(next==null)
            tail = prev;
        else {
            next.prev = prev;
            tmp.next=null;      //take care!!
        }
    }

    public boolean deleteByNode(Node node) {
        if(node==null || head==null) return false;

        Node h = head,p=null;
        while(h!=null && h!=node) {
            p = h;
            h = h.next;
        }

        Node t;
        if(h == null) {
           return false;
        }else {
            t = h.next;

            if(p!=null)
                p.next = t;
            else
                head = t;

            if(t!=null)
                t.prev = p;
            else
                tail = p;

            h.next = h.prev = null;
        }

        length--;
        node.prev=node.next = null;

        return true;
    }

    public Node find(int data) {
        if(head == null || tail==null) return null;

        Node h = head;
        while(h!=null && h.item!=data) {
            h = h.next;
        }

        return h;
    }

    public Node findPrev(int data) {
        if(head==null || tail==null) return null;

        Node h = head;
        Node p = null;
        while(h!=null && h.item!=data) {
            p = h;
            h = h.next;
        }

        if(p==null || h==null) return null;
        else return p;
    }




    public static class Node{
        public int item;
        public Node prev;
        public Node next;

        Node(int item) {
            this.item = item;
        }
    }
}
```

```.java
package algo;

import collection.LinkedList;
import static collection.LinkedList.Node;

public class LinkedListAlgo {

    //1) reverse the list
    public static LinkedList reverse(LinkedList list) {
        if(list==null || list.length==1) return list;

        Node oldHead = list.head;
        Node oldTail = list.tail;

        Node h = oldHead,tmp,t=null;
        while(h!=null) {
            //get the cur node
            tmp = h;

            //change the cur node
            h = h.next;
            if(h!=null)
                h.prev = null;

            //reverse
            // t=null -> the first reverse step
            tmp.next = t;
            if(t!=null) {
                t.prev = tmp;
            }

            t = tmp;
        }

        oldTail.prev = null;
        list.head = t;

        oldHead.next = null;
        list.tail = oldHead;

        return list;
    }

    //2) check if this list contains circle
    public static boolean checkCircle(LinkedList list) {
        if(list==null || list.length==0)
            return false;

        Node slow = list.head;
        Node fast = list.head.next;

        while(fast!=null && fast.next!=null) {
            slow = slow.next;
            fast = fast.next.next;

            if(slow==fast)
                return true;
        }

        return false;
    }

    //3) merge two sorted list
    public static LinkedList mergeSortedLists(LinkedList la, LinkedList lb) {
        if (la==null || la.length==0) return lb;
        if (lb==null || lb.length==0) return la;

        Node p = la.head;
        Node q = lb.head;
        Node head;
        if (p.item < q.item) {
            head = p;
            p = p.next;
        } else {
            head = q;
            q = q.next;
        }

        Node h = head;

        Node r = head;
        while (p != null && q != null) {
            if (p.item < q.item) {
                r.next = p;
                p.prev = r;

                p = p.next;
            } else {
                r.next = q;
                q.prev = r;

                q = q.next;
            }
            r = r.next;
        }

        LinkedList list = new LinkedList();
        list.head = h;

        if (p != null) {
            r.next = p;
            p.prev = r;
            list.tail = la.tail;
        } else {
            r.next = q;
            q.prev = r;
            list.tail = lb.tail;
        }

        return list;
    }

    //4) delete the last Kth node
    public static LinkedList deleteLastKth(LinkedList list,int kth) {
        if(list==null || kth==0)
            return null;

        int count = 0;
        Node p = list.head;
        while(count<kth && p!=null) {
            p = p.next;
            count++;
        }

        if(p==null) {
           Node t = list.head.next;
           list.head.next = null;
           list.head = t;
           
           if(list.head!=null)
               list.head.prev = null;

           list.length--;

           return list;
        }

        Node q = list.head;
        Node prev = null;
        while(p.next!=null) {
            prev = q;
            q = q.next;
            p = p.next;
        }

        if (prev == null) {
            Node t = list.head.next;
            list.head.next = t.next;
            t.next.prev = list.head;

            t.next = t.prev = null;
        } else {
            Node t = prev.next;
            prev.next = t.next;
            t.next.prev = prev;

            t.next = t.prev = null;
        }

        list.length--;

        return list;
    }

    // 5) find the middle node of list
    public static Node findMiddleNode(LinkedList list) {
        if (list.head == null) return null;

        Node fast = list.head;
        Node slow = list.head;

        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow;
    }
}
```
### 二叉树

```
package collection;

public class BinarySearchTree {
    private TreeNode root;

    public void  insert(int item) {
        if(root==null)
            root = new TreeNode(item,null,null);

        TreeNode t = root;
        while(t!=null) {
            if(item<t.item) {
                if(t.left==null) {
                    t.left = new TreeNode(item,null,null);
                    return;
                }

                t = t.left;
            }else if(item>t.item) {
                if(t.right==null) {
                    t.right = new TreeNode(item,null,null);
                    return;
                }

                t = t.right;
            }else {
                return;
            }
        }
    }

    public boolean remove(int key) {
        TreeNode t = root;
        TreeNode p = null;
        while(t!=null && t.item!=key) {
            p = t;
            if(key<t.item) t = t.left;
            else t = t.right;
        }

        if(t==null) return false;

        if(t.left!=null && t.right!=null) {
            TreeNode minT = t.right;
            TreeNode minP = t;
            while(minT!=null && minT.left!=null) {
                minP = minT;
                minT = minT.left;
            }

            t.item = minT.item;
            t = minT;
            p = minP;
        }

        TreeNode child;
        if(t.left!=null) child = t.left;
        else if(t.right!=null) child = t.right;
        else child = null;

        if(p==null) root = child;
        else if(t==p.left) p.left = child;
        else p.right = child;

        return true;
    }

    public TreeNode findMin(TreeNode node) {
        TreeNode t = node;
        TreeNode p = null;
        while(t!=null) {
            p = t;
            t = t.left;
        }

        return p;
    }

    public TreeNode find(int key) {
        TreeNode t = root;
        while(t!=null) {
            if(key<t.item) t = t.left;
            else if(key>t.item) t = t.right;
            else return t;
        }

        return null;
    }

    public TreeNode findPrev(int key) {
        TreeNode t = root;
        TreeNode p = null;
        while(t!=null && t.item!=key) {
            p = t;
            if(key<t.item) t = t.left;
            else t = t.right;
        }

        if(p==null || t==null) return null;
        else return p;
    }

    public static class TreeNode {
        int item;
        TreeNode left;
        TreeNode right;

        public TreeNode() {}

        public TreeNode(int item,TreeNode left,TreeNode right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}
```


<img src="https://people.engr.ncsu.edu/efg/210/s99/Notes/LLdefs.gif" height="150" weight="200"/>

### 链表+数组思想的结合产物

#### SkipList

```.java
/**
    how SkipList code and how it look like!! 
*/
import java.util.Random;

public class SkipList {
    private int levelCount = 0;
    private static final int MAXLEVEl = 16;
    private Node head = new Node();
    private Random random = new Random();

    public void insert(int value) {
        int level = randomLevel();

        Node node = new Node();
        node.value = value;
        node.level = level;

        Node[] updates = new Node[level];
        for(int i=0; i<level; i++)
            updates[i] = head;

        Node p = head;
        for(int i=level-1; i>=0; i--) {
            while(p.forwards[i]!=null && p.forwards[i].value<value)
                p = p.forwards[i];

            updates[i] = p;
        }

        //insert value with updates[]
        for(int i=level-1; i>=0; i--) {
            node.forwards[i] = updates[i].forwards[i];
            updates[i].forwards[i] = node;
        }

        if(level>levelCount) levelCount=level;
    }

    public boolean delete(int key) {
        Node[] updates = new Node[levelCount];
        Node p = head;
        for(int i=levelCount-1; i>=0; i--) {
            while(p.forwards[i]!=null && p.forwards[i].value<key)
                p = p.forwards[i];

            updates[i] = p;
        }

        //delete the node map key
        if(p.forwards[0]!=null && p.forwards[0].value==key) {
            for(int i=levelCount-1; i>=0; i--) {
                if(updates[i].forwards[i]!=null && updates[i].forwards[i].value==key)
                    updates[i].forwards[i] = updates[i].forwards[i].forwards[i];
            }

            return true;
        }

        return false;
    }

    public Node find(int key) {
        Node[] updates = new Node[levelCount];
        Node p = head;
        for(int i=levelCount-1; i>=0; i--) {
            while(p.forwards[i]!=null && p.forwards[i].value<key)
                p = p.forwards[i];

            updates[i] = p;
        }

        if(p.forwards[0]!=null && p.forwards[0].value==key)
            return p.forwards[0];
        else
            return null;
    }

    private int randomLevel() {
        int level = 0;
        for(int i=0; i<MAXLEVEl; i++) {
            if(random.nextInt()%2 == 1) level++;
        }
        return level;
    }

    static class Node {
        int value;
        int level;
        Node[] forwards = new Node[MAXLEVEl];
    }
}
```
<img src="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/Skip-List-3-4.jpg" height="150" weight="200"/>

### HashMap

```.java
public class HashMap<K,V> {
    private int capacity = 16;
    private int size = 0;
    private float loadFactor = 0.75f;
    @SuppressWarnings({"rawtypes","unchecked"})
    private Node<K,V>[] buckets = (Node<K,V>[])new Node[capacity];

    /**
     * @param key the key map with the value,can be null;
     * @param value the value map with the key,can be null;
     * @return return old value if hash node's key map with the given key,else return null;
     */
    public V put(K key, V value) {
        int c = capacity;
        int hash = hash(key);

        int t;
        if(buckets[t=(c-1)&hash] == null) {
            buckets[t] = new Node<>(key,value,null);
        }else {
            Node<K,V> h = buckets[t];
            Node<K,V> p = h;
            while(h!=null) {
                if(h.key==key || (h.key!=null && h.key.equals(key))) {
                    break;
                }
                p = h;
                h = h.next;
            }

            if(h!=null) {
               V old = h.value;
               h.value = value;
               return old;
            }

            p.next = new Node<>(key,value,null);
        }

        if(++size > capacity*loadFactor)
            resize();

        return null;
    }

    private void resize() {
        int c = capacity;
        int newC = capacity*2;  // todo prevent newC > integer.max
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newBuckets = (Node<K,V>[])new Node[newC];

        Node<K,V> cur,t,h=null,l=null;
        for(int i=0;i<c; i++) {
            cur = buckets[i];
            while(cur != null) {
                t = cur;
                cur = cur.next;

                if((c&hash(t.key)) != 0) {
                    t.next = h;
                    h = t;
                }else {
                    t.next = l;
                    l = t;
                }
            }

            newBuckets[i] = l;
            newBuckets[i+c] = h;
        }

        buckets = newBuckets;
        capacity = newC;
    }

    public V remove(Object key) {
        int hash = hash(key);
        int n = capacity;

        Node<K,V> h;
        if((h=buckets[(n-1)&hash]) == null) {
            return null;
        }else {
            Node<K,V> p = h;
            Node<K,V> q = h;
            while(h!=null && !(h.key==key || (h.key!=null && h.key.equals(key)))) {
                p = h;
                h = h.next;
            }

            //have no the node map with the given key,so return null
            if(h==null)
                return null;

            if(p==q)
                buckets[(n-1)&hash] = p.next;
            else {
                p.next = h.next;
                h.next = null;
            }
        }

        size--;

        return h.value;
    }

    static final int hash(Object key) {
        int h;
        return key==null? 0: (h=key.hashCode())^(h>>16);
    }

    static class Node<K,V> {
        private K key;
        private V value;
        Node<K,V> next;

        public Node(K key,V value,Node<K,V> next) {
            this.key = key;
            this.value = value;
            this.next  = next;
        }
    }
}
```
<img src="https://deepakvadgama.com/images/blog/hashmap.jpg" height="150" weight="200"/>

## 排序

<img src="https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" height="150" weight="200"/>

### O(n*lgn)

#### MergeSort 

```.java
/*
    1.MergeSort,a stable sorts Algo,but it  need extraly O(n) memory space. 
    2.The optimization for MergeSortr is TimSort. 
*/
public class MergeSort {
	private int[] tmp;

	public MergeSort(int n) {
		this.tmp = new int[n];
	}

	public class MergeSort(int[] data,int n) {
		MergesortInternally(data,0,n-1);
	}	

	public void MergesortInternally(int[] data,int lo,int hi) {
		if(lo>=hi) return;

		int mi = lo+(hi-lo)/2;

		MergesortInternally(data,lo,mi);
		MergesortInternally(data,mi+1,hi);

		merge(data,lo,mi,mi+1,hi);
	}

	public void merge(int[] data,int lo1,hi1,lo2,hi2) {
		int h = lo1;
		while(lo1<=hi1 && lo2<=hi2) {
			if(data[lo1]<=data[lo2]) {
				tmp[h++] = data[lo1++];
			}else {
				tmp[h++] = data[lo2++];
			}
		}	

		while(lo1<=hi1)
			tmp[h++] = data[lo1++];
		while(lo2<=hi2)
			tmp[h++] = data[lo2++];
	}
}
```
<img src="https://pythonandr.files.wordpress.com/2015/07/mergesort1.jpg" height="150" weight="200"/>

福利： 改进 MergeSort的算法： [TimSort.java](https://github.com/unofficial-openjdk/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/TimSort.java) 。在TimSort.java 也讲述了其源码设计的相关彩蛋，具体的请自行挖掘。

### QuickSort

```.java

public class QuickSort {

    public int[]  quickSort(int[] data,int n) {
        quickSortInterternally(data,0,n-1);
        return data;
    }

    private void quickSortInterternally(int[] data,int lo,int hi) {
        if(lo>=hi) return;

        int p = partition(data,lo,hi);

        quickSortInterternally(data,lo,p-1);
        quickSortInterternally(data,p+1,hi);
    }
    
    private int partition(int[] data,int lo,int hi) {
        int pivot = data[lo];
        int i = hi;
        for(int j=hi;j>lo;j--) {
            if(data[j]>pivot) {
                int tmp = data[i];
                data[i] = data[j];
                data[j] = tmp;

                i--;
            }
        }

        int tmp = data[i];
        data[i] = data[lo];
        data[lo] = tmp;

        return i;
    }

}
```

<img src="http://interactivepython.org/courselib/static/pythonds/_images/partitionA.png" height="200" weight="200"/>

福利：改进QuickSort的算法：[DualPivotQuicksort.java](https://github.com/unofficial-openjdk/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/DualPivotQuicksort.java)
## Q＆Ａ
 
- 1.为何DualPivotQuicksort快？？
- 2.cpu读取数据、写数据的完整过程？
<br> [2.1 how a CPU work ?](https://www.youtube.com/watch?v=cNN_tTXABUA)
<br>[2.2 cpu cache explained](https://www.youtube.com/watch?v=yi0FhRqDJfo)
